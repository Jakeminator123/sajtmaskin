
Guide: Använda Meshy API och visa en 3D‑figur på din egen webbplats
=================================================================

Den här filen ger en enkel översikt över hur du kan:
1. Använda Meshys API för att skapa och rigga en 3D‑karaktär.
2. Skapa flera animationer (t.ex. ~30 st) för samma karaktär.
3. Visa modellen och byta animationer på din egen sajt med three.js.

Observera:
- Meshy‑API:t används på serversidan (Python i exemplen).
- Själva visningen av modellen sker i webbläsaren med JavaScript (three.js).
- Lägg aldrig din Meshy API‑nyckel direkt i klient‑JavaScript.

------------------------------------------------------------
1. API‑nyckel och grundidé
------------------------------------------------------------

1) Gå till Meshy‑sidan för API‑inställningar och skapa en API‑nyckel.
   Exempel: "msy_...".

2) Den här nyckeln används i HTTP‑anrop (t.ex. via Python + requests)
   för att:
   - skapa/generera 3D‑modeller (Text to 3D, Image to 3D, etc)
   - auto‑rigga modellen (få skelett/ben så att den kan animeras)
   - skapa animationer till en riggad modell

3) Flödet blir typ:
   - Skapa/eller ladda upp modell
   - Rigga modellen (rigging)
   - Skapa många animationer från Meshys animation‑bibliotek
   - Ladda ner GLB/FBX‑filerna till din egen server eller lagring
   - Visa modellen i webbläsaren (three.js) och byt animationer där

------------------------------------------------------------
2. Enkel Python‑backend som pratar med Meshy
------------------------------------------------------------

Nedan är exempel på Python‑kod (skript eller backend) som använder
requests. Du kan köra det på din Windows‑maskin. Se till att ha
`pip install requests` och att du har satt environment‑variabeln
MESHY_API_KEY.

Filen visar tre huvuddelar:
- create_character_from_text: skapar en 3D‑modell från text
- rig_character_from_task: riggar modellen
- create_animation: skapar en animation för riggad modell

Obs: detta är förenklad kod, men visar principen.

------------------------------------------------------------
2.1 Python‑exempel
------------------------------------------------------------

import os
import time
import requests

API_KEY = os.environ["MESHY_API_KEY"]
BASE_URL = "https://api.meshy.ai"

HEADERS = {
    "Authorization": f"Bearer {API_KEY}",
    "Content-Type": "application/json",
}


def wait_for_task(path: str, task_id: str) -> str:
    """Pollar Meshy‑task tills status = SUCCEEDED eller FAILED."""
    while True:
        r = requests.get(f"{BASE_URL}{path}/{task_id}", headers=HEADERS)
        r.raise_for_status()
        data = r.json()
        status = data["status"]
        if status == "SUCCEEDED":
            return task_id
        if status in ("FAILED", "CANCELED"):
            raise RuntimeError(f"Task {task_id} failed: {data.get('task_error')}")
        time.sleep(3)


def create_character_from_text(prompt: str) -> str:
    """Skapa en Text‑to‑3D‑modell och returnera refine_task_id."""
    # 1) Preview
    resp = requests.post(
        f"{BASE_URL}/openapi/v2/text-to-3d",
        headers=HEADERS,
        json={
            "mode": "preview",
            "prompt": prompt,
            "model": "meshy-6-preview",  # eller "latest"
        },
    )
    resp.raise_for_status()
    preview_id = resp.json()["result"]

    # Vänta tills preview är klar
    preview_id = wait_for_task("/openapi/v2/text-to-3d", preview_id)

    # 2) Refine
    resp = requests.post(
        f"{BASE_URL}/openapi/v2/text-to-3d",
        headers=HEADERS,
        json={
            "mode": "refine",
            "preview_task_id": preview_id,
            "enable_pbr": True,
        },
    )
    resp.raise_for_status()
    refine_id = resp.json()["result"]

    refine_id = wait_for_task("/openapi/v2/text-to-3d", refine_id)
    return refine_id


def rig_character_from_task(input_task_id: str) -> dict:
    """Auto‑rigga modellen baserat på Text‑to‑3D‑task."""
    resp = requests.post(
        f"{BASE_URL}/openapi/v1/rigging",
        headers=HEADERS,
        json={
            "input_task_id": input_task_id,
            "height_meters": 1.8,
        },
    )
    resp.raise_for_status()
    rig_task_id = resp.json()["result"]

    # Vänta tills rigging är klar
    while True:
        r = requests.get(f"{BASE_URL}/openapi/v1/rigging/{rig_task_id}", headers=HEADERS)
        r.raise_for_status()
        data = r.json()
        status = data["status"]
        if status == "SUCCEEDED":
            return data["result"]  # innehåller t.ex. rigged_character_glb_url
        if status in ("FAILED", "CANCELED"):
            raise RuntimeError(f"Rigging failed: {data.get('task_error')}")
        time.sleep(3)


def create_animation(rig_task_id: str, action_id: int) -> dict:
    """Skapa EN animation för en riggad karaktär."""
    resp = requests.post(
        f"{BASE_URL}/openapi/v1/animations",
        headers=HEADERS,
        json={
            "rig_task_id": rig_task_id,
            "action_id": action_id,
        },
    )
    resp.raise_for_status()
    anim_task_id = resp.json()["result"]

    # Vänta tills animationen är klar
    while True:
        r = requests.get(f"{BASE_URL}/openapi/v1/animations/{anim_task_id}", headers=HEADERS)
        r.raise_for_status()
        data = r.json()
        status = data["status"]
        if status == "SUCCEEDED":
            return data["result"]  # innehåller t.ex. animation_glb_url
        if status in ("FAILED", "CANCELED"):
            raise RuntimeError(f"Animation failed: {data.get('task_error')}")
        time.sleep(3)


if __name__ == "__main__":
    # 1) Skapa karaktären från text
    refine_task_id = create_character_from_text("a stylized warrior character")

    # 2) Rigga modellen
    rig_result = rig_character_from_task(refine_task_id)
    rigged_char_glb = rig_result["rigged_character_glb_url"]
    # I verkligheten vill du även spara själva rig_task_id när du skapar riggen.

    # 3) Skapa ~30 animationer (exempel: action_id 0..29)
    animation_urls = {}
    for action_id in range(0, 30):
        result = create_animation(rig_task_id="DIN_RIG_TASK_ID_HÄR", action_id=action_id)
        animation_urls[action_id] = result["animation_glb_url"]

    # Här kan du ladda ner GLB‑filerna till disk / molnlagring osv.


------------------------------------------------------------
3. Visa modellen och animationerna med three.js
------------------------------------------------------------

När du har din riggade modell och animationerna (ofta ihopbakade i ett
enda GLB‑paket med flera animationer/“clips”) kan du visa dem i
webbläsaren.

Standard‑workflow:
- Lägg character.glb i t.ex. /public/models/
- Ladda den med GLTFLoader i three.js
- Skapa en AnimationMixer
- Lägg alla clips i en lista och koppla till en <select> eller knappar
- När användaren väljer en animation: stoppa den gamla och spela den nya

------------------------------------------------------------
3.1 Exempel‑HTML (three.js)
------------------------------------------------------------

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Meshy Character Viewer</title>
    <style>
      body { margin: 0; overflow: hidden; background: #111; color: #fff; }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        padding: 8px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 4px;
        font-family: sans-serif;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <label for="animSelect">Animation:</label>
      <select id="animSelect"></select>
    </div>
    <canvas id="c"></canvas>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js";
      import { OrbitControls } from "https://unpkg.com/three@0.165.0/examples/jsm/controls/OrbitControls.js";
      import { GLTFLoader } from "https://unpkg.com/three@0.165.0/examples/jsm/loaders/GLTFLoader.js";

      const canvas = document.getElementById("c");
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x202020);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 1.6, 3);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 1.2, 0);
      controls.update();

      const light = new THREE.DirectionalLight(0xffffff, 1.0);
      light.position.set(2, 4, 2);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0xffffff, 0.3));

      const loader = new GLTFLoader();

      let mixer;
      const actions = {};
      let activeAction;
      const animSelect = document.getElementById("animSelect");

      loader.load("/models/character.glb", (gltf) => {
        const model = gltf.scene;
        model.traverse((obj) => {
          if (obj.isMesh) {
            obj.castShadow = true;
            obj.receiveShadow = true;
          }
        });
        scene.add(model);

        mixer = new THREE.AnimationMixer(model);

        gltf.animations.forEach((clip) => {
          const action = mixer.clipAction(clip);
          actions[clip.name] = action;

          const option = document.createElement("option");
          option.value = clip.name;
          option.textContent = clip.name;
          animSelect.appendChild(option);
        });

        if (gltf.animations.length > 0) {
          setActiveAction(gltf.animations[0].name);
        }
      });

      function setActiveAction(name) {
        if (!actions[name]) return;
        if (activeAction) {
          activeAction.stop();
        }
        activeAction = actions[name];
        activeAction.reset().play();
      }

      animSelect.addEventListener("change", () => {
        setActiveAction(animSelect.value);
      });

      const clock = new THREE.Clock();

      function resizeRendererToDisplaySize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const needResize =
          canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
        }
      }

      function render() {
        resizeRendererToDisplaySize();
        const delta = clock.getDelta();
        if (mixer) mixer.update(delta);
        renderer.render(scene, camera);
        requestAnimationFrame(render);
      }
      render();
    </script>
  </body>
</html>


------------------------------------------------------------
4. Saker att tänka på
------------------------------------------------------------

- Lägg API‑nyckeln på serversidan (t.ex. environment‑variabel).
- Meshy‑tasks (text‑to‑3d, rigging, animations) tar tid – använd polling
  eller ett kö‑system i din backend.
- När modellen är klar, försök baka ihop så många animationer som möjligt
  i ett enda GLB (t.ex. via Blender) så blir det färre HTTP‑anrop från
  webbläsaren.
- Testa modellerna i en enkel lokal HTML‑fil först, sedan kan du flytta
  över till din riktiga sajt.
